Program Laba8;
{Дана матрица ArrSort[9,7]. Упорядочить элементы столб-
 цов матрицы по неубыванию, а сами столбцы по возраста-
 нию произведения модулей нечетных элементов столбцов}

// Консольное приложение
{$APPTYPE CONSOLE}

// Объявление констант
Const
  N=9;
  M=7;
// N,M - размерность массива

// Объявление переменных
Var
  I,J,L,Temp,Left,Right,Middle:integer;
  ArrSort,ArrSaved:array [1..N,1..M] of integer;
  Multiply:array[1..M] of integer;
  Flag:boolean;
// I,J,L - счетчик цикла
// Temp - обмен элементов при сортировке
// Left - левая граница отсортированной части массива
// Right - правая граница отсортированного массива
// Middle - середина отсортированного массива
// ArrSort - исходный массив
// ArrSaved - копия исходного массива
// Multiply - массив, содержащий произведения модулей 
// нечетных элементов столбцов
// Flag - проверка небходисти сортировки при использо-
// вании "плавающего пузырька"

begin

  // Заполенение исходного массива с использованием ге-
  // нератора случайных чисел
  for I:=1 to N do
  begin
    randomize;
    for J:=1 to M do
      ArrSort[I,J]:=random(100)-50;
  end;


  // Вывод исходного массива
  writeln('Array:');
  for I:=1 to N do
  begin
    writeln;
    for J:=1 to M do
      write(ArrSort[I,J]:3);
  end;

  // Сохранение исходного массива
  ArrSaved:=ArrSort;

  (*Начало цикла А1 по J. J изменяет свое значение от 1 
    до M с шагом 1. Перебор столбцов при сортировке их 
    элементов методом бинарных вставок*)
  for J:=1 to M do

    (*Начало цикла А1.1 по I. I изменяет свои значения 
      от 2 до N с шагом 1. Сортировка элементов столб-
      цов по неубыванию с использованием алгоритма би-
      нарных вставок*)
    for I:=2 to N do
    begin

      // Сохранение сравниваемого элемента
      Temp:=ArrSort[I,J];
 
      // Определение левой и правой границ
      Left:=1;
      Right:=I;

      (*Начало цикла А1.1.1. Цикл выполняется до тех 
        пор, пока левая граница не превысит значение 
        правой*)
      while Left<Right do
      begin
 
        // Определение середины отсортированной части
        Middle:=(Left+Right) div 2;

        // Обновление границ
        if ArrSort[Middle,J]<Temp then
          Left:=Middle+1
        else
          Right:=Middle;
      end;
      // Конец цикла А1.1.1

      (*Начало цикла А1.1.2 по L. L изменяет свои 
        значения от I до Right+1 с шагом 1. Сдвиг эле-
        ментов массива вправо*)
      for L:=I downto Right+1 do
        ArrSort[L,J]:=ArrSort[L-1,J];
      // Конец цикла А1.1.2

      // Внесение сохраненнго элемента в отсортирован-
      // ную часть массива
      ArrSort[Right,J]:=Temp;
    end;

  // Вывод отсортированного массива
  writeln;
  writeln;
  writeln('Sorted column elements:');
  for I:=1 to N do
  begin
    writeln;
    for J:=1 to M do
      write(ArrSort[I,J]:3);
  end;

  // Присвоение начальных значений. Т.к. массив содер-
  // жит результаты произведения, элементы приравнива-
  // ются к 1
  for J:=1 to M do
    Multiply[J]:=1;

  (*Начало цикла А2 по J. J изменяет свои значения от 1 
    до M с шагом 1. Вычисление произведений модулей не-
    четных элементов столбцов*)
  for J:=1 to M do
  begin
    L:=1;

    (*Начало цикла А2.1. Цикл выполняется до тех пор, 
      пока не произойдет выход за границы массива. Осу-
      ществляется подсчет произведения модулей нечетных 
      элементов данного стобца*)
    repeat
      Multiply[J]:=abs(ArrSort[L,J]*Multiply[J]);
      L:=L+2;
    until L>N;
    // Конец цикла А2.1

  end;
  // Конец цикла А2
  (*Начало цикла А3 по J. J изменяет свои значания от 1 
    до M-1 с шагом 1. Сортировка столбцов исходного 
    массива с использование алгоритма "плавающий пузы-
    рек"*)
  for J:=1 to M-1 do

    // Проверка нарушения сортирующего условия
    if Multiply[J]>Multiply[J+1] then
    begin

      // Выполнение сортировки массива, содержащего ре-
      // зультаты произведения
      Temp:=Multiply[J];
      Multiply[J]:=Multiply[J+1];
      Multiply[J+1]:=Temp;

      (*Начало цикла А3.1 по I. I изменяет свои значе-
        ния от 1 до N с шагом 1. Обмен двух столбцов*)
      for I:=1 to N do
      begin
        Temp:=ArrSort[I,J];
        ArrSort[I,J]:=ArrSort[I,J+1];
        ArrSort[I,J+1]:=Temp;
      end;
      // Конец цикла А3.1
 
      // Присвоение начальных значений
      L:=J;
      Flag:=true;

      (*Начало цикла А3.2. Цикла выполняется до тех 
        пор, пока не произойдет выход за границы мас-
        сива, либо предыдущий елемен не станет меньше 
        следующего*)
      while (L>1) and (Flag=true) do

        // Проверка выполнения сортирующего условия
        if Multiply[L-1]>Multiply[L] then
        begin
          Temp:=Multiply[L];
          Multiply[L]:=Multiply[L-1];
          Multiply[L-1]:=Temp;






          (*Начало цикла А3.2.1 по I. I изменяет свои 
            значения от 1 до N с шагом 1. Элементы ме-
            няются между собой*)
          for I:=1 to N do
          begin
            Temp:=ArrSort[I,L];
            ArrSort[I,L]:=ArrSort[I,L-1];
            ArrSort[I,L-1]:=Temp;
          end;
          // Конец цикла А3.2.1
         
          // Уменьшение индекса массива
          L:=L-1;

        end

        // Если сортирующее условие не нарушено, осу-
        // ществляется выход из цикла
        else
          Flag:=false;
    end;
    // Конец цикла А3.2

  // Конец цикла А3

  // Вывод полученного массива
  writeln;
  writeln;
  writeln('Sorted columns:');
  for I:=1 to N do
  begin
    writeln;
    for J:=1 to M do
      write(ArrSort[I,J]:3);
  end;

  readln;
end.

